---
title: "HW2"
author: "Garrett Pinkston"
format: html
editor: visual
---

## **Problem 1 - Dice Game**

a\) Build the following versions

-   Version 1: Implement this game using a loop.

```{r}

loopDiceGame <- function(nrolls){
  wallet <- 0
  for (i in 1:nrolls) {
    roll <- sample(1:6,1)
    if ((roll == 3) || (roll == 5)) {
    wallet <- wallet + (2 * roll)
    }
    wallet <- wallet - 2
  }
  return(wallet)
}

set.seed(123)
loopDiceGame(3000)
```

-   Version 2: Implement this game using built-in R vectorized functions.

```{r}

vectorizedDiceGame <- function(nrolls){
  wallet <- 0
  
  allRolls <- sample(1:6,nrolls,replace=TRUE)
  
  wallet <- (allRolls == 3 | allRolls == 5) * 2 *allRolls
  wallet <- sum(wallet) - (2*nrolls)
  
  return(wallet)
}

set.seed(123)
vectorizedDiceGame(3000)
```

-   Version 3: Implement this by rolling all the dice into one and collapsing the die rolls into a single `table()`. (Hint: Be careful indexing the table - what happens if you make a table of a single dice roll? You may need to look to other resources for how to solve this.)

```{r}
tableDiceGame <- function(nrolls){
  wallet <- 0

  allRolls <- sample(1:6,nrolls,replace=TRUE)
  allRolls <- factor(allRolls,levels=1:6) #need to ensure all counts appear in table (even if num wasn't rolled)
  
  rollsTable <- table(allRolls)
  
  profitForThrees <- as.numeric(rollsTable["3"]) * 2 * 3 # numOccurences * payoff * numberProfit
  profitForFives <- as.numeric(rollsTable["5"]) * 2 * 5 # numOccurences * payoff * numberProfit
  
  wallet <- profitForThrees + profitForFives
  wallet <- wallet - (2 * nrolls)
  
  return(wallet)
}
set.seed(123)
tableDiceGame(3000)
```

-   Version 4: Implement this game by using one of the “`apply`” functions.

```{r}
applyDiceGame <- function(nrolls){
  wallet <- 0

  allRolls <- sample(1:6,nrolls,replace=TRUE)
  
  allProfits <- vapply(allRolls,function(individualRoll){
      if ((individualRoll == 3) || (individualRoll == 5)) {
        return(as.integer(2 * individualRoll))
      } else{
        return(0L)
      }
  },integer(1))
  
  wallet <- sum(allProfits)
  wallet <- wallet - (2 * nrolls)
  return(wallet)
}
set.seed(123)
applyDiceGame(3000)
```

b\) Demonstrate that all versions work. Do so by running each a few times, once with an input a 3, and once with an input of 3,000.
```{r}
loopDiceGame(3)
loopDiceGame(3000)

vectorizedDiceGame(3)
vectorizedDiceGame(3000)

tableDiceGame(3)
tableDiceGame(3000)

applyDiceGame(3)
applyDiceGame(3000)

```
as we can observe, all functions work and provide output. 8 functions were tested and 8 reasonable pieces of output were returned.

c\) Demonstrate that the four versions give the same result. Test with inputs 3 and 3,000. (You will need to add a way to control the randomization.)

```{r}
set.seed(130)
loopDiceGame(3)

set.seed(130)
vectorizedDiceGame(3)

set.seed(130)
tableDiceGame(3)

set.seed(130)
applyDiceGame(3)


set.seed(130)
loopDiceGame(3000)

set.seed(130)
vectorizedDiceGame(3000)

set.seed(130)
tableDiceGame(3000)

set.seed(130)
applyDiceGame(3000)

```

d\) Use the microbenchmark package to clearly demonstrate the speed of the implementations. Compare performance with a low input (1,000) and a large input (100,000). Discuss the results

```{r}
library(microbenchmark)

small_benchmark <- microbenchmark(
  loop = loopDiceGame(1000),
  vectorized = vectorizedDiceGame(1000),
  table = tableDiceGame(1000),
  vapply = applyDiceGame(1000),
  times = 100 # Run each function 100 times for better averaging
)

print(small_benchmark)

# Run benchmark for large input (100,000 rolls)
large_benchmark <- microbenchmark(
  loop = play_dice_loop(100000),
  vectorized = play_dice_vectorized(100000),
  table = play_dice_table(100000),
  vapply = applyDiceGame(100000),
  times = 10 # Large inputs, fewer iterations due to time
)

print(large_benchmark)

```

e\) Do you think this is a fair game? Defend your decision with evidence based upon a Monte Carlo simulation.







You can add options to executable code like this

```{r}
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
